# 后端异常处理框架说明

## 📋 框架概述

本项目实现了一套统一的、模块化的异常处理框架，所有业务异常都通过自定义的 `BusinessException` 进行管理，由全局异常处理器 `GlobalExceptionHandler` 统一处理并返回标准的 API 响应格式。

## 🏗️ 框架组件

### 1. BusinessException（业务异常类）
**文件**: `com.cjh.backend.exception.BusinessException`

- 继承 `RuntimeException`
- 包含错误码 (`code`) 和错误信息 (`message`)
- 用于表示所有业务逻辑中的错误情况

**使用示例**:
```java
throw new BusinessException("用户不存在");
throw new BusinessException(400, "参数错误");
```

### 2. ErrorConstants（错误常量）
**文件**: `com.cjh.backend.exception.ErrorConstants`

- 集中定义所有错误信息常量
- 避免硬编码字符串，便于统一维护
- 按模块分类（商品、订单、用户、权限等）

**使用示例**:
```java
throw new BusinessException(ErrorConstants.PRODUCT_NOT_EXIST);
throw new BusinessException(ErrorConstants.ORDER_NOT_OWNED);
```

### 3. GlobalExceptionHandler（全局异常处理器）
**文件**: `com.cjh.backend.exception.GlobalExceptionHandler`

- 使用 `@RestControllerAdvice` 注解
- 处理三类异常：
  - `BusinessException` - 业务异常
  - `MethodArgumentNotValidException` - 参数验证异常
  - `Exception` - 其他系统异常

**统一响应格式**:
```json
{
  "code": 400,
  "message": "错误信息",
  "data": null
}
```

## 📝 服务层异常处理

### 已实现的异常处理

#### 1. **OrdersServiceImpl** - 订单服务
- ✅ `createOrder()` - 创建订单时的商品校验
- ✅ `payOrder()` - 支付订单时的权限和状态校验
- ✅ `completeOrder()` - 完成订单时的权限和支付状态校验
- ✅ `cancelOrder()` - 取消订单时的权限和状态校验

#### 2. **ProductServiceImpl** - 商品服务
- ✅ `publishProduct()` - 发布商品时的数据库操作异常
- ✅ `updateProductInfo()` - 修改商品时的权限和状态校验
- ✅ `updateProductStatus()` - 更新状态时的有效性校验
- ✅ `deleteProduct()` - 删除商品时的权限和状态校验
- ✅ `getProductDetail()` - 获取详情时的存在性校验
- ✅ `listProductsByCategory()` - 按分类查询时的参数校验
- ✅ `markProductSold()` - 标记已售时的状态校验

#### 3. **AuthServiceImpl** - 认证服务
- ✅ `login()` - 登录时的用户名密码和账号状态校验
- ✅ `register()` - 注册时的用户名重复校验

#### 4. **UserServiceImpl** - 用户服务
- ✅ `updateUserInfo()` - 修改用户信息时的用户存在性校验
- ✅ `updatePassword()` - 修改密码时的原密码验证和新旧密码校验

## 🔄 异常处理流程

```
业务逻辑发生错误
    ↓
抛出 BusinessException
    ↓
GlobalExceptionHandler 捕获
    ↓
返回标准 Result 格式
    ↓
前端接收响应
```

## 💡 最佳实践

### ✅ DO（应该做）

```java
// 1. 使用异常常量
if (product == null) {
    throw new BusinessException(ErrorConstants.PRODUCT_NOT_EXIST);
}

// 2. 早期返回避免嵌套
if (!validateCondition) {
    throw new BusinessException("条件不满足");
}
// 正常逻辑继续...

// 3. 包含关键信息
if (!order.getBuyerId().equals(buyerId)) {
    throw new BusinessException(ErrorConstants.ORDER_NOT_OWNED);
}
```

### ❌ DON'T（不应该做）

```java
// 1. 不要使用硬编码字符串
throw new RuntimeException("商品不存在");  // ❌ 避免

// 2. 不要吞掉异常
try {
    // 某个操作
} catch (Exception e) {
    // 不做任何处理
}  // ❌ 避免

// 3. 不要抛出通用异常
throw new Exception("错误");  // ❌ 避免
```

## 🔐 安全性考虑

- 异常信息不会暴露系统内部细节
- GlobalExceptionHandler 捕获所有异常，防止泄露
- 系统异常返回通用错误信息

## 📊 错误码对照表

| 错误类型 | 错误码 | 处理方式 |
|---------|--------|---------|
| 业务异常 | 400 | 返回具体错误信息 |
| 参数错误 | 400 | 返回字段验证错误 |
| 系统异常 | 500 | 返回通用错误信息 |

## 🔧 扩展方法

如需添加新的异常处理：

1. 在 `ErrorConstants` 中添加新的错误常量
2. 在业务逻辑中使用该常量抛出异常
3. 如需特殊处理，在 `GlobalExceptionHandler` 中添加新的 `@ExceptionHandler` 方法

**示例**:
```java
// 1. 添加常量
public static final String NEW_ERROR = "新的错误信息";

// 2. 在服务中使用
throw new BusinessException(ErrorConstants.NEW_ERROR);

// 3. 如需特殊处理（可选）
@ExceptionHandler(SpecialException.class)
public Result<?> handleSpecialException(SpecialException e) {
    // 特殊处理逻辑
    return Result.fail(...);
}
```

## 📚 文件结构

```
exception/
├── BusinessException.java      # 业务异常类
├── ErrorConstants.java         # 错误常量定义
└── GlobalExceptionHandler.java # 全局异常处理器

service/impl/
├── AuthServiceImpl.java         # 认证服务 ✅
├── UserServiceImpl.java         # 用户服务 ✅
├── ProductServiceImpl.java      # 商品服务 ✅
└── OrdersServiceImpl.java       # 订单服务 ✅
```

---

**框架完成日期**: 2026-01-20
**所有关键业务逻辑**已完成异常处理实现 ✅
